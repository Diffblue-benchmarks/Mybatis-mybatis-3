


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: MapperAnnotationBuilder</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">org.apache.ibatis.builder.annotation</a> ]
</div>

<h1>Coverage Summary for Class: MapperAnnotationBuilder (org.apache.ibatis.builder.annotation)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">MapperAnnotationBuilder</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (32/ 32)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    97.7%
  </span>
  <span class="absValue">
    (333/ 341)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/**
<i>2</i>&nbsp; *    Copyright 2009-2019 the original author or authors.
<i>3</i>&nbsp; *
<i>4</i>&nbsp; *    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
<i>5</i>&nbsp; *    you may not use this file except in compliance with the License.
<i>6</i>&nbsp; *    You may obtain a copy of the License at
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *       http://www.apache.org/licenses/LICENSE-2.0
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *    Unless required by applicable law or agreed to in writing, software
<i>11</i>&nbsp; *    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
<i>12</i>&nbsp; *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
<i>13</i>&nbsp; *    See the License for the specific language governing permissions and
<i>14</i>&nbsp; *    limitations under the License.
<i>15</i>&nbsp; */
<i>16</i>&nbsp;package org.apache.ibatis.builder.annotation;
<i>17</i>&nbsp;
<i>18</i>&nbsp;import java.io.IOException;
<i>19</i>&nbsp;import java.io.InputStream;
<i>20</i>&nbsp;import java.lang.annotation.Annotation;
<i>21</i>&nbsp;import java.lang.reflect.Array;
<i>22</i>&nbsp;import java.lang.reflect.GenericArrayType;
<i>23</i>&nbsp;import java.lang.reflect.Method;
<i>24</i>&nbsp;import java.lang.reflect.ParameterizedType;
<i>25</i>&nbsp;import java.lang.reflect.Type;
<i>26</i>&nbsp;import java.util.ArrayList;
<i>27</i>&nbsp;import java.util.Collection;
<i>28</i>&nbsp;import java.util.HashMap;
<i>29</i>&nbsp;import java.util.HashSet;
<i>30</i>&nbsp;import java.util.Iterator;
<i>31</i>&nbsp;import java.util.List;
<i>32</i>&nbsp;import java.util.Locale;
<i>33</i>&nbsp;import java.util.Map;
<i>34</i>&nbsp;import java.util.Optional;
<i>35</i>&nbsp;import java.util.Properties;
<i>36</i>&nbsp;import java.util.Set;
<i>37</i>&nbsp;
<i>38</i>&nbsp;import org.apache.ibatis.annotations.Arg;
<i>39</i>&nbsp;import org.apache.ibatis.annotations.CacheNamespace;
<i>40</i>&nbsp;import org.apache.ibatis.annotations.CacheNamespaceRef;
<i>41</i>&nbsp;import org.apache.ibatis.annotations.Case;
<i>42</i>&nbsp;import org.apache.ibatis.annotations.ConstructorArgs;
<i>43</i>&nbsp;import org.apache.ibatis.annotations.Delete;
<i>44</i>&nbsp;import org.apache.ibatis.annotations.DeleteProvider;
<i>45</i>&nbsp;import org.apache.ibatis.annotations.Insert;
<i>46</i>&nbsp;import org.apache.ibatis.annotations.InsertProvider;
<i>47</i>&nbsp;import org.apache.ibatis.annotations.Lang;
<i>48</i>&nbsp;import org.apache.ibatis.annotations.MapKey;
<i>49</i>&nbsp;import org.apache.ibatis.annotations.Options;
<i>50</i>&nbsp;import org.apache.ibatis.annotations.Options.FlushCachePolicy;
<i>51</i>&nbsp;import org.apache.ibatis.annotations.Property;
<i>52</i>&nbsp;import org.apache.ibatis.annotations.Result;
<i>53</i>&nbsp;import org.apache.ibatis.annotations.ResultMap;
<i>54</i>&nbsp;import org.apache.ibatis.annotations.ResultType;
<i>55</i>&nbsp;import org.apache.ibatis.annotations.Results;
<i>56</i>&nbsp;import org.apache.ibatis.annotations.Select;
<i>57</i>&nbsp;import org.apache.ibatis.annotations.SelectKey;
<i>58</i>&nbsp;import org.apache.ibatis.annotations.SelectProvider;
<i>59</i>&nbsp;import org.apache.ibatis.annotations.TypeDiscriminator;
<i>60</i>&nbsp;import org.apache.ibatis.annotations.Update;
<i>61</i>&nbsp;import org.apache.ibatis.annotations.UpdateProvider;
<i>62</i>&nbsp;import org.apache.ibatis.binding.BindingException;
<i>63</i>&nbsp;import org.apache.ibatis.binding.MapperMethod.ParamMap;
<i>64</i>&nbsp;import org.apache.ibatis.builder.BuilderException;
<i>65</i>&nbsp;import org.apache.ibatis.builder.CacheRefResolver;
<i>66</i>&nbsp;import org.apache.ibatis.builder.IncompleteElementException;
<i>67</i>&nbsp;import org.apache.ibatis.builder.MapperBuilderAssistant;
<i>68</i>&nbsp;import org.apache.ibatis.builder.xml.XMLMapperBuilder;
<i>69</i>&nbsp;import org.apache.ibatis.cursor.Cursor;
<i>70</i>&nbsp;import org.apache.ibatis.executor.keygen.Jdbc3KeyGenerator;
<i>71</i>&nbsp;import org.apache.ibatis.executor.keygen.KeyGenerator;
<i>72</i>&nbsp;import org.apache.ibatis.executor.keygen.NoKeyGenerator;
<i>73</i>&nbsp;import org.apache.ibatis.executor.keygen.SelectKeyGenerator;
<i>74</i>&nbsp;import org.apache.ibatis.io.Resources;
<i>75</i>&nbsp;import org.apache.ibatis.mapping.Discriminator;
<i>76</i>&nbsp;import org.apache.ibatis.mapping.FetchType;
<i>77</i>&nbsp;import org.apache.ibatis.mapping.MappedStatement;
<i>78</i>&nbsp;import org.apache.ibatis.mapping.ResultFlag;
<i>79</i>&nbsp;import org.apache.ibatis.mapping.ResultMapping;
<i>80</i>&nbsp;import org.apache.ibatis.mapping.ResultSetType;
<i>81</i>&nbsp;import org.apache.ibatis.mapping.SqlCommandType;
<i>82</i>&nbsp;import org.apache.ibatis.mapping.SqlSource;
<i>83</i>&nbsp;import org.apache.ibatis.mapping.StatementType;
<i>84</i>&nbsp;import org.apache.ibatis.parsing.PropertyParser;
<i>85</i>&nbsp;import org.apache.ibatis.reflection.TypeParameterResolver;
<i>86</i>&nbsp;import org.apache.ibatis.scripting.LanguageDriver;
<i>87</i>&nbsp;import org.apache.ibatis.session.Configuration;
<i>88</i>&nbsp;import org.apache.ibatis.session.ResultHandler;
<i>89</i>&nbsp;import org.apache.ibatis.session.RowBounds;
<i>90</i>&nbsp;import org.apache.ibatis.type.JdbcType;
<i>91</i>&nbsp;import org.apache.ibatis.type.TypeHandler;
<i>92</i>&nbsp;import org.apache.ibatis.type.UnknownTypeHandler;
<i>93</i>&nbsp;
<i>94</i>&nbsp;/**
<i>95</i>&nbsp; * @author Clinton Begin
<i>96</i>&nbsp; * @author Kazuki Shimizu
<i>97</i>&nbsp; */
<i>98</i>&nbsp;public class MapperAnnotationBuilder {
<i>99</i>&nbsp;
<b class="fc"><i>100</i>&nbsp;  private static final Set&lt;Class&lt;? extends Annotation&gt;&gt; SQL_ANNOTATION_TYPES = new HashSet&lt;&gt;();</b>
<b class="fc"><i>101</i>&nbsp;  private static final Set&lt;Class&lt;? extends Annotation&gt;&gt; SQL_PROVIDER_ANNOTATION_TYPES = new HashSet&lt;&gt;();</b>
<i>102</i>&nbsp;
<i>103</i>&nbsp;  private final Configuration configuration;
<i>104</i>&nbsp;  private final MapperBuilderAssistant assistant;
<i>105</i>&nbsp;  private final Class&lt;?&gt; type;
<i>106</i>&nbsp;
<i>107</i>&nbsp;  static {
<b class="fc"><i>108</i>&nbsp;    SQL_ANNOTATION_TYPES.add(Select.class);</b>
<b class="fc"><i>109</i>&nbsp;    SQL_ANNOTATION_TYPES.add(Insert.class);</b>
<b class="fc"><i>110</i>&nbsp;    SQL_ANNOTATION_TYPES.add(Update.class);</b>
<b class="fc"><i>111</i>&nbsp;    SQL_ANNOTATION_TYPES.add(Delete.class);</b>
<i>112</i>&nbsp;
<b class="fc"><i>113</i>&nbsp;    SQL_PROVIDER_ANNOTATION_TYPES.add(SelectProvider.class);</b>
<b class="fc"><i>114</i>&nbsp;    SQL_PROVIDER_ANNOTATION_TYPES.add(InsertProvider.class);</b>
<b class="fc"><i>115</i>&nbsp;    SQL_PROVIDER_ANNOTATION_TYPES.add(UpdateProvider.class);</b>
<b class="fc"><i>116</i>&nbsp;    SQL_PROVIDER_ANNOTATION_TYPES.add(DeleteProvider.class);</b>
<b class="fc"><i>117</i>&nbsp;  }</b>
<i>118</i>&nbsp;
<b class="fc"><i>119</i>&nbsp;  public MapperAnnotationBuilder(Configuration configuration, Class&lt;?&gt; type) {</b>
<b class="fc"><i>120</i>&nbsp;    String resource = type.getName().replace(&#39;.&#39;, &#39;/&#39;) + &quot;.java (best guess)&quot;;</b>
<b class="fc"><i>121</i>&nbsp;    this.assistant = new MapperBuilderAssistant(configuration, resource);</b>
<b class="fc"><i>122</i>&nbsp;    this.configuration = configuration;</b>
<b class="fc"><i>123</i>&nbsp;    this.type = type;</b>
<b class="fc"><i>124</i>&nbsp;  }</b>
<i>125</i>&nbsp;
<i>126</i>&nbsp;  public void parse() {
<b class="fc"><i>127</i>&nbsp;    String resource = type.toString();</b>
<b class="fc"><i>128</i>&nbsp;    if (!configuration.isResourceLoaded(resource)) {</b>
<b class="fc"><i>129</i>&nbsp;      loadXmlResource();</b>
<b class="fc"><i>130</i>&nbsp;      configuration.addLoadedResource(resource);</b>
<b class="fc"><i>131</i>&nbsp;      assistant.setCurrentNamespace(type.getName());</b>
<b class="fc"><i>132</i>&nbsp;      parseCache();</b>
<b class="fc"><i>133</i>&nbsp;      parseCacheRef();</b>
<b class="fc"><i>134</i>&nbsp;      Method[] methods = type.getMethods();</b>
<b class="fc"><i>135</i>&nbsp;      for (Method method : methods) {</b>
<i>136</i>&nbsp;        try {
<i>137</i>&nbsp;          // issue #237
<b class="fc"><i>138</i>&nbsp;          if (!method.isBridge()) {</b>
<b class="fc"><i>139</i>&nbsp;            parseStatement(method);</b>
<i>140</i>&nbsp;          }
<b class="fc"><i>141</i>&nbsp;        } catch (IncompleteElementException e) {</b>
<b class="fc"><i>142</i>&nbsp;          configuration.addIncompleteMethod(new MethodResolver(this, method));</b>
<b class="fc"><i>143</i>&nbsp;        }</b>
<i>144</i>&nbsp;      }
<i>145</i>&nbsp;    }
<b class="fc"><i>146</i>&nbsp;    parsePendingMethods();</b>
<b class="fc"><i>147</i>&nbsp;  }</b>
<i>148</i>&nbsp;
<i>149</i>&nbsp;  private void parsePendingMethods() {
<b class="fc"><i>150</i>&nbsp;    Collection&lt;MethodResolver&gt; incompleteMethods = configuration.getIncompleteMethods();</b>
<b class="fc"><i>151</i>&nbsp;    synchronized (incompleteMethods) {</b>
<b class="fc"><i>152</i>&nbsp;      Iterator&lt;MethodResolver&gt; iter = incompleteMethods.iterator();</b>
<b class="fc"><i>153</i>&nbsp;      while (iter.hasNext()) {</b>
<i>154</i>&nbsp;        try {
<b class="fc"><i>155</i>&nbsp;          iter.next().resolve();</b>
<b class="fc"><i>156</i>&nbsp;          iter.remove();</b>
<b class="fc"><i>157</i>&nbsp;        } catch (IncompleteElementException e) {</b>
<i>158</i>&nbsp;          // This method is still missing a resource
<b class="fc"><i>159</i>&nbsp;        }</b>
<i>160</i>&nbsp;      }
<b class="fc"><i>161</i>&nbsp;    }</b>
<b class="fc"><i>162</i>&nbsp;  }</b>
<i>163</i>&nbsp;
<i>164</i>&nbsp;  private void loadXmlResource() {
<i>165</i>&nbsp;    // Spring may not know the real resource name so we check a flag
<i>166</i>&nbsp;    // to prevent loading again a resource twice
<i>167</i>&nbsp;    // this flag is set at XMLMapperBuilder#bindMapperForNamespace
<b class="fc"><i>168</i>&nbsp;    if (!configuration.isResourceLoaded(&quot;namespace:&quot; + type.getName())) {</b>
<b class="fc"><i>169</i>&nbsp;      String xmlResource = type.getName().replace(&#39;.&#39;, &#39;/&#39;) + &quot;.xml&quot;;</b>
<i>170</i>&nbsp;      // #1347
<b class="fc"><i>171</i>&nbsp;      InputStream inputStream = type.getResourceAsStream(&quot;/&quot; + xmlResource);</b>
<b class="fc"><i>172</i>&nbsp;      if (inputStream == null) {</b>
<i>173</i>&nbsp;        // Search XML mapper that is not in the module but in the classpath.
<i>174</i>&nbsp;        try {
<b class="fc"><i>175</i>&nbsp;          inputStream = Resources.getResourceAsStream(type.getClassLoader(), xmlResource);</b>
<b class="fc"><i>176</i>&nbsp;        } catch (IOException e2) {</b>
<i>177</i>&nbsp;          // ignore, resource is not required
<b class="nc"><i>178</i>&nbsp;        }</b>
<i>179</i>&nbsp;      }
<b class="fc"><i>180</i>&nbsp;      if (inputStream != null) {</b>
<b class="fc"><i>181</i>&nbsp;        XMLMapperBuilder xmlParser = new XMLMapperBuilder(inputStream, assistant.getConfiguration(), xmlResource, configuration.getSqlFragments(), type.getName());</b>
<b class="fc"><i>182</i>&nbsp;        xmlParser.parse();</b>
<i>183</i>&nbsp;      }
<i>184</i>&nbsp;    }
<b class="fc"><i>185</i>&nbsp;  }</b>
<i>186</i>&nbsp;
<i>187</i>&nbsp;  private void parseCache() {
<b class="fc"><i>188</i>&nbsp;    CacheNamespace cacheDomain = type.getAnnotation(CacheNamespace.class);</b>
<b class="fc"><i>189</i>&nbsp;    if (cacheDomain != null) {</b>
<b class="fc"><i>190</i>&nbsp;      Integer size = cacheDomain.size() == 0 ? null : cacheDomain.size();</b>
<b class="fc"><i>191</i>&nbsp;      Long flushInterval = cacheDomain.flushInterval() == 0 ? null : cacheDomain.flushInterval();</b>
<b class="fc"><i>192</i>&nbsp;      Properties props = convertToProperties(cacheDomain.properties());</b>
<b class="fc"><i>193</i>&nbsp;      assistant.useNewCache(cacheDomain.implementation(), cacheDomain.eviction(), flushInterval, size, cacheDomain.readWrite(), cacheDomain.blocking(), props);</b>
<i>194</i>&nbsp;    }
<b class="fc"><i>195</i>&nbsp;  }</b>
<i>196</i>&nbsp;
<i>197</i>&nbsp;  private Properties convertToProperties(Property[] properties) {
<b class="fc"><i>198</i>&nbsp;    if (properties.length == 0) {</b>
<b class="fc"><i>199</i>&nbsp;      return null;</b>
<i>200</i>&nbsp;    }
<b class="fc"><i>201</i>&nbsp;    Properties props = new Properties();</b>
<b class="fc"><i>202</i>&nbsp;    for (Property property : properties) {</b>
<b class="fc"><i>203</i>&nbsp;      props.setProperty(property.name(),</b>
<b class="fc"><i>204</i>&nbsp;          PropertyParser.parse(property.value(), configuration.getVariables()));</b>
<i>205</i>&nbsp;    }
<b class="fc"><i>206</i>&nbsp;    return props;</b>
<i>207</i>&nbsp;  }
<i>208</i>&nbsp;
<i>209</i>&nbsp;  private void parseCacheRef() {
<b class="fc"><i>210</i>&nbsp;    CacheNamespaceRef cacheDomainRef = type.getAnnotation(CacheNamespaceRef.class);</b>
<b class="fc"><i>211</i>&nbsp;    if (cacheDomainRef != null) {</b>
<b class="fc"><i>212</i>&nbsp;      Class&lt;?&gt; refType = cacheDomainRef.value();</b>
<b class="fc"><i>213</i>&nbsp;      String refName = cacheDomainRef.name();</b>
<b class="fc"><i>214</i>&nbsp;      if (refType == void.class &amp;&amp; refName.isEmpty()) {</b>
<b class="fc"><i>215</i>&nbsp;        throw new BuilderException(&quot;Should be specified either value() or name() attribute in the @CacheNamespaceRef&quot;);</b>
<i>216</i>&nbsp;      }
<b class="fc"><i>217</i>&nbsp;      if (refType != void.class &amp;&amp; !refName.isEmpty()) {</b>
<b class="fc"><i>218</i>&nbsp;        throw new BuilderException(&quot;Cannot use both value() and name() attribute in the @CacheNamespaceRef&quot;);</b>
<i>219</i>&nbsp;      }
<b class="fc"><i>220</i>&nbsp;      String namespace = (refType != void.class) ? refType.getName() : refName;</b>
<i>221</i>&nbsp;      try {
<b class="fc"><i>222</i>&nbsp;        assistant.useCacheRef(namespace);</b>
<b class="fc"><i>223</i>&nbsp;      } catch (IncompleteElementException e) {</b>
<b class="fc"><i>224</i>&nbsp;        configuration.addIncompleteCacheRef(new CacheRefResolver(assistant, namespace));</b>
<b class="fc"><i>225</i>&nbsp;      }</b>
<i>226</i>&nbsp;    }
<b class="fc"><i>227</i>&nbsp;  }</b>
<i>228</i>&nbsp;
<i>229</i>&nbsp;  private String parseResultMap(Method method) {
<b class="fc"><i>230</i>&nbsp;    Class&lt;?&gt; returnType = getReturnType(method);</b>
<b class="fc"><i>231</i>&nbsp;    ConstructorArgs args = method.getAnnotation(ConstructorArgs.class);</b>
<b class="fc"><i>232</i>&nbsp;    Results results = method.getAnnotation(Results.class);</b>
<b class="fc"><i>233</i>&nbsp;    TypeDiscriminator typeDiscriminator = method.getAnnotation(TypeDiscriminator.class);</b>
<b class="fc"><i>234</i>&nbsp;    String resultMapId = generateResultMapName(method);</b>
<b class="fc"><i>235</i>&nbsp;    applyResultMap(resultMapId, returnType, argsIf(args), resultsIf(results), typeDiscriminator);</b>
<b class="fc"><i>236</i>&nbsp;    return resultMapId;</b>
<i>237</i>&nbsp;  }
<i>238</i>&nbsp;
<i>239</i>&nbsp;  private String generateResultMapName(Method method) {
<b class="fc"><i>240</i>&nbsp;    Results results = method.getAnnotation(Results.class);</b>
<b class="fc"><i>241</i>&nbsp;    if (results != null &amp;&amp; !results.id().isEmpty()) {</b>
<b class="fc"><i>242</i>&nbsp;      return type.getName() + &quot;.&quot; + results.id();</b>
<i>243</i>&nbsp;    }
<b class="fc"><i>244</i>&nbsp;    StringBuilder suffix = new StringBuilder();</b>
<b class="fc"><i>245</i>&nbsp;    for (Class&lt;?&gt; c : method.getParameterTypes()) {</b>
<b class="fc"><i>246</i>&nbsp;      suffix.append(&quot;-&quot;);</b>
<b class="fc"><i>247</i>&nbsp;      suffix.append(c.getSimpleName());</b>
<i>248</i>&nbsp;    }
<b class="fc"><i>249</i>&nbsp;    if (suffix.length() &lt; 1) {</b>
<b class="fc"><i>250</i>&nbsp;      suffix.append(&quot;-void&quot;);</b>
<i>251</i>&nbsp;    }
<b class="fc"><i>252</i>&nbsp;    return type.getName() + &quot;.&quot; + method.getName() + suffix;</b>
<i>253</i>&nbsp;  }
<i>254</i>&nbsp;
<i>255</i>&nbsp;  private void applyResultMap(String resultMapId, Class&lt;?&gt; returnType, Arg[] args, Result[] results, TypeDiscriminator discriminator) {
<b class="fc"><i>256</i>&nbsp;    List&lt;ResultMapping&gt; resultMappings = new ArrayList&lt;&gt;();</b>
<b class="fc"><i>257</i>&nbsp;    applyConstructorArgs(args, returnType, resultMappings);</b>
<b class="fc"><i>258</i>&nbsp;    applyResults(results, returnType, resultMappings);</b>
<b class="fc"><i>259</i>&nbsp;    Discriminator disc = applyDiscriminator(resultMapId, returnType, discriminator);</b>
<i>260</i>&nbsp;    // TODO add AutoMappingBehaviour
<b class="fc"><i>261</i>&nbsp;    assistant.addResultMap(resultMapId, returnType, null, disc, resultMappings, null);</b>
<b class="fc"><i>262</i>&nbsp;    createDiscriminatorResultMaps(resultMapId, returnType, discriminator);</b>
<b class="fc"><i>263</i>&nbsp;  }</b>
<i>264</i>&nbsp;
<i>265</i>&nbsp;  private void createDiscriminatorResultMaps(String resultMapId, Class&lt;?&gt; resultType, TypeDiscriminator discriminator) {
<b class="fc"><i>266</i>&nbsp;    if (discriminator != null) {</b>
<b class="fc"><i>267</i>&nbsp;      for (Case c : discriminator.cases()) {</b>
<b class="fc"><i>268</i>&nbsp;        String caseResultMapId = resultMapId + &quot;-&quot; + c.value();</b>
<b class="fc"><i>269</i>&nbsp;        List&lt;ResultMapping&gt; resultMappings = new ArrayList&lt;&gt;();</b>
<i>270</i>&nbsp;        // issue #136
<b class="fc"><i>271</i>&nbsp;        applyConstructorArgs(c.constructArgs(), resultType, resultMappings);</b>
<b class="fc"><i>272</i>&nbsp;        applyResults(c.results(), resultType, resultMappings);</b>
<i>273</i>&nbsp;        // TODO add AutoMappingBehaviour
<b class="fc"><i>274</i>&nbsp;        assistant.addResultMap(caseResultMapId, c.type(), resultMapId, null, resultMappings, null);</b>
<i>275</i>&nbsp;      }
<i>276</i>&nbsp;    }
<b class="fc"><i>277</i>&nbsp;  }</b>
<i>278</i>&nbsp;
<i>279</i>&nbsp;  private Discriminator applyDiscriminator(String resultMapId, Class&lt;?&gt; resultType, TypeDiscriminator discriminator) {
<b class="fc"><i>280</i>&nbsp;    if (discriminator != null) {</b>
<b class="fc"><i>281</i>&nbsp;      String column = discriminator.column();</b>
<b class="fc"><i>282</i>&nbsp;      Class&lt;?&gt; javaType = discriminator.javaType() == void.class ? String.class : discriminator.javaType();</b>
<b class="fc"><i>283</i>&nbsp;      JdbcType jdbcType = discriminator.jdbcType() == JdbcType.UNDEFINED ? null : discriminator.jdbcType();</b>
<i>284</i>&nbsp;      @SuppressWarnings(&quot;unchecked&quot;)
<b class="fc"><i>285</i>&nbsp;      Class&lt;? extends TypeHandler&lt;?&gt;&gt; typeHandler = (Class&lt;? extends TypeHandler&lt;?&gt;&gt;)</b>
<b class="fc"><i>286</i>&nbsp;              (discriminator.typeHandler() == UnknownTypeHandler.class ? null : discriminator.typeHandler());</b>
<b class="fc"><i>287</i>&nbsp;      Case[] cases = discriminator.cases();</b>
<b class="fc"><i>288</i>&nbsp;      Map&lt;String, String&gt; discriminatorMap = new HashMap&lt;&gt;();</b>
<b class="fc"><i>289</i>&nbsp;      for (Case c : cases) {</b>
<b class="fc"><i>290</i>&nbsp;        String value = c.value();</b>
<b class="fc"><i>291</i>&nbsp;        String caseResultMapId = resultMapId + &quot;-&quot; + value;</b>
<b class="fc"><i>292</i>&nbsp;        discriminatorMap.put(value, caseResultMapId);</b>
<i>293</i>&nbsp;      }
<b class="fc"><i>294</i>&nbsp;      return assistant.buildDiscriminator(resultType, column, javaType, jdbcType, typeHandler, discriminatorMap);</b>
<i>295</i>&nbsp;    }
<b class="fc"><i>296</i>&nbsp;    return null;</b>
<i>297</i>&nbsp;  }
<i>298</i>&nbsp;
<i>299</i>&nbsp;  void parseStatement(Method method) {
<b class="fc"><i>300</i>&nbsp;    Class&lt;?&gt; parameterTypeClass = getParameterType(method);</b>
<b class="fc"><i>301</i>&nbsp;    LanguageDriver languageDriver = getLanguageDriver(method);</b>
<b class="fc"><i>302</i>&nbsp;    SqlSource sqlSource = getSqlSourceFromAnnotations(method, parameterTypeClass, languageDriver);</b>
<b class="fc"><i>303</i>&nbsp;    if (sqlSource != null) {</b>
<b class="fc"><i>304</i>&nbsp;      Options options = method.getAnnotation(Options.class);</b>
<b class="fc"><i>305</i>&nbsp;      final String mappedStatementId = type.getName() + &quot;.&quot; + method.getName();</b>
<b class="fc"><i>306</i>&nbsp;      Integer fetchSize = null;</b>
<b class="fc"><i>307</i>&nbsp;      Integer timeout = null;</b>
<b class="fc"><i>308</i>&nbsp;      StatementType statementType = StatementType.PREPARED;</b>
<b class="fc"><i>309</i>&nbsp;      ResultSetType resultSetType = null;</b>
<b class="fc"><i>310</i>&nbsp;      SqlCommandType sqlCommandType = getSqlCommandType(method);</b>
<b class="fc"><i>311</i>&nbsp;      boolean isSelect = sqlCommandType == SqlCommandType.SELECT;</b>
<b class="fc"><i>312</i>&nbsp;      boolean flushCache = !isSelect;</b>
<b class="fc"><i>313</i>&nbsp;      boolean useCache = isSelect;</b>
<i>314</i>&nbsp;
<i>315</i>&nbsp;      KeyGenerator keyGenerator;
<b class="fc"><i>316</i>&nbsp;      String keyProperty = null;</b>
<b class="fc"><i>317</i>&nbsp;      String keyColumn = null;</b>
<b class="fc"><i>318</i>&nbsp;      if (SqlCommandType.INSERT.equals(sqlCommandType) || SqlCommandType.UPDATE.equals(sqlCommandType)) {</b>
<i>319</i>&nbsp;        // first check for SelectKey annotation - that overrides everything else
<b class="fc"><i>320</i>&nbsp;        SelectKey selectKey = method.getAnnotation(SelectKey.class);</b>
<b class="fc"><i>321</i>&nbsp;        if (selectKey != null) {</b>
<b class="fc"><i>322</i>&nbsp;          keyGenerator = handleSelectKeyAnnotation(selectKey, mappedStatementId, getParameterType(method), languageDriver);</b>
<b class="fc"><i>323</i>&nbsp;          keyProperty = selectKey.keyProperty();</b>
<b class="fc"><i>324</i>&nbsp;        } else if (options == null) {</b>
<b class="fc"><i>325</i>&nbsp;          keyGenerator = configuration.isUseGeneratedKeys() ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;</b>
<i>326</i>&nbsp;        } else {
<b class="fc"><i>327</i>&nbsp;          keyGenerator = options.useGeneratedKeys() ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;</b>
<b class="fc"><i>328</i>&nbsp;          keyProperty = options.keyProperty();</b>
<b class="fc"><i>329</i>&nbsp;          keyColumn = options.keyColumn();</b>
<i>330</i>&nbsp;        }
<b class="fc"><i>331</i>&nbsp;      } else {</b>
<b class="fc"><i>332</i>&nbsp;        keyGenerator = NoKeyGenerator.INSTANCE;</b>
<i>333</i>&nbsp;      }
<i>334</i>&nbsp;
<b class="fc"><i>335</i>&nbsp;      if (options != null) {</b>
<b class="fc"><i>336</i>&nbsp;        if (FlushCachePolicy.TRUE.equals(options.flushCache())) {</b>
<b class="fc"><i>337</i>&nbsp;          flushCache = true;</b>
<b class="fc"><i>338</i>&nbsp;        } else if (FlushCachePolicy.FALSE.equals(options.flushCache())) {</b>
<b class="fc"><i>339</i>&nbsp;          flushCache = false;</b>
<i>340</i>&nbsp;        }
<b class="fc"><i>341</i>&nbsp;        useCache = options.useCache();</b>
<b class="fc"><i>342</i>&nbsp;        fetchSize = options.fetchSize() &gt; -1 || options.fetchSize() == Integer.MIN_VALUE ? options.fetchSize() : null; //issue #348</b>
<b class="fc"><i>343</i>&nbsp;        timeout = options.timeout() &gt; -1 ? options.timeout() : null;</b>
<b class="fc"><i>344</i>&nbsp;        statementType = options.statementType();</b>
<b class="fc"><i>345</i>&nbsp;        resultSetType = options.resultSetType();</b>
<i>346</i>&nbsp;      }
<i>347</i>&nbsp;
<b class="fc"><i>348</i>&nbsp;      String resultMapId = null;</b>
<b class="fc"><i>349</i>&nbsp;      ResultMap resultMapAnnotation = method.getAnnotation(ResultMap.class);</b>
<b class="fc"><i>350</i>&nbsp;      if (resultMapAnnotation != null) {</b>
<b class="fc"><i>351</i>&nbsp;        resultMapId = String.join(&quot;,&quot;, resultMapAnnotation.value());</b>
<b class="fc"><i>352</i>&nbsp;      } else if (isSelect) {</b>
<b class="fc"><i>353</i>&nbsp;        resultMapId = parseResultMap(method);</b>
<i>354</i>&nbsp;      }
<i>355</i>&nbsp;
<b class="fc"><i>356</i>&nbsp;      assistant.addMappedStatement(</b>
<i>357</i>&nbsp;          mappedStatementId,
<i>358</i>&nbsp;          sqlSource,
<i>359</i>&nbsp;          statementType,
<i>360</i>&nbsp;          sqlCommandType,
<i>361</i>&nbsp;          fetchSize,
<i>362</i>&nbsp;          timeout,
<i>363</i>&nbsp;          // ParameterMapID
<i>364</i>&nbsp;          null,
<i>365</i>&nbsp;          parameterTypeClass,
<i>366</i>&nbsp;          resultMapId,
<b class="fc"><i>367</i>&nbsp;          getReturnType(method),</b>
<i>368</i>&nbsp;          resultSetType,
<i>369</i>&nbsp;          flushCache,
<i>370</i>&nbsp;          useCache,
<i>371</i>&nbsp;          // TODO gcode issue #577
<i>372</i>&nbsp;          false,
<i>373</i>&nbsp;          keyGenerator,
<i>374</i>&nbsp;          keyProperty,
<i>375</i>&nbsp;          keyColumn,
<i>376</i>&nbsp;          // DatabaseID
<i>377</i>&nbsp;          null,
<i>378</i>&nbsp;          languageDriver,
<i>379</i>&nbsp;          // ResultSets
<b class="fc"><i>380</i>&nbsp;          options != null ? nullOrEmpty(options.resultSets()) : null);</b>
<i>381</i>&nbsp;    }
<b class="fc"><i>382</i>&nbsp;  }</b>
<i>383</i>&nbsp;
<i>384</i>&nbsp;  private LanguageDriver getLanguageDriver(Method method) {
<b class="fc"><i>385</i>&nbsp;    Lang lang = method.getAnnotation(Lang.class);</b>
<b class="fc"><i>386</i>&nbsp;    Class&lt;? extends LanguageDriver&gt; langClass = null;</b>
<b class="fc"><i>387</i>&nbsp;    if (lang != null) {</b>
<b class="fc"><i>388</i>&nbsp;      langClass = lang.value();</b>
<i>389</i>&nbsp;    }
<b class="fc"><i>390</i>&nbsp;    return assistant.getLanguageDriver(langClass);</b>
<i>391</i>&nbsp;  }
<i>392</i>&nbsp;
<i>393</i>&nbsp;  private Class&lt;?&gt; getParameterType(Method method) {
<b class="fc"><i>394</i>&nbsp;    Class&lt;?&gt; parameterType = null;</b>
<b class="fc"><i>395</i>&nbsp;    Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</b>
<b class="fc"><i>396</i>&nbsp;    for (Class&lt;?&gt; currentParameterType : parameterTypes) {</b>
<b class="fc"><i>397</i>&nbsp;      if (!RowBounds.class.isAssignableFrom(currentParameterType) &amp;&amp; !ResultHandler.class.isAssignableFrom(currentParameterType)) {</b>
<b class="fc"><i>398</i>&nbsp;        if (parameterType == null) {</b>
<b class="fc"><i>399</i>&nbsp;          parameterType = currentParameterType;</b>
<i>400</i>&nbsp;        } else {
<i>401</i>&nbsp;          // issue #135
<b class="fc"><i>402</i>&nbsp;          parameterType = ParamMap.class;</b>
<i>403</i>&nbsp;        }
<i>404</i>&nbsp;      }
<i>405</i>&nbsp;    }
<b class="fc"><i>406</i>&nbsp;    return parameterType;</b>
<i>407</i>&nbsp;  }
<i>408</i>&nbsp;
<i>409</i>&nbsp;  private Class&lt;?&gt; getReturnType(Method method) {
<b class="fc"><i>410</i>&nbsp;    Class&lt;?&gt; returnType = method.getReturnType();</b>
<b class="fc"><i>411</i>&nbsp;    Type resolvedReturnType = TypeParameterResolver.resolveReturnType(method, type);</b>
<b class="fc"><i>412</i>&nbsp;    if (resolvedReturnType instanceof Class) {</b>
<b class="fc"><i>413</i>&nbsp;      returnType = (Class&lt;?&gt;) resolvedReturnType;</b>
<b class="fc"><i>414</i>&nbsp;      if (returnType.isArray()) {</b>
<b class="fc"><i>415</i>&nbsp;        returnType = returnType.getComponentType();</b>
<i>416</i>&nbsp;      }
<i>417</i>&nbsp;      // gcode issue #508
<b class="fc"><i>418</i>&nbsp;      if (void.class.equals(returnType)) {</b>
<b class="fc"><i>419</i>&nbsp;        ResultType rt = method.getAnnotation(ResultType.class);</b>
<b class="fc"><i>420</i>&nbsp;        if (rt != null) {</b>
<b class="fc"><i>421</i>&nbsp;          returnType = rt.value();</b>
<i>422</i>&nbsp;        }
<b class="fc"><i>423</i>&nbsp;      }</b>
<b class="fc"><i>424</i>&nbsp;    } else if (resolvedReturnType instanceof ParameterizedType) {</b>
<b class="fc"><i>425</i>&nbsp;      ParameterizedType parameterizedType = (ParameterizedType) resolvedReturnType;</b>
<b class="fc"><i>426</i>&nbsp;      Class&lt;?&gt; rawType = (Class&lt;?&gt;) parameterizedType.getRawType();</b>
<b class="fc"><i>427</i>&nbsp;      if (Collection.class.isAssignableFrom(rawType) || Cursor.class.isAssignableFrom(rawType)) {</b>
<b class="fc"><i>428</i>&nbsp;        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();</b>
<b class="fc"><i>429</i>&nbsp;        if (actualTypeArguments != null &amp;&amp; actualTypeArguments.length == 1) {</b>
<b class="fc"><i>430</i>&nbsp;          Type returnTypeParameter = actualTypeArguments[0];</b>
<b class="fc"><i>431</i>&nbsp;          if (returnTypeParameter instanceof Class&lt;?&gt;) {</b>
<b class="fc"><i>432</i>&nbsp;            returnType = (Class&lt;?&gt;) returnTypeParameter;</b>
<b class="fc"><i>433</i>&nbsp;          } else if (returnTypeParameter instanceof ParameterizedType) {</b>
<i>434</i>&nbsp;            // (gcode issue #443) actual type can be a also a parameterized type
<b class="fc"><i>435</i>&nbsp;            returnType = (Class&lt;?&gt;) ((ParameterizedType) returnTypeParameter).getRawType();</b>
<b class="nc"><i>436</i>&nbsp;          } else if (returnTypeParameter instanceof GenericArrayType) {</b>
<b class="nc"><i>437</i>&nbsp;            Class&lt;?&gt; componentType = (Class&lt;?&gt;) ((GenericArrayType) returnTypeParameter).getGenericComponentType();</b>
<i>438</i>&nbsp;            // (gcode issue #525) support List&lt;byte[]&gt;
<b class="nc"><i>439</i>&nbsp;            returnType = Array.newInstance(componentType, 0).getClass();</b>
<i>440</i>&nbsp;          }
<i>441</i>&nbsp;        }
<b class="fc"><i>442</i>&nbsp;      } else if (method.isAnnotationPresent(MapKey.class) &amp;&amp; Map.class.isAssignableFrom(rawType)) {</b>
<i>443</i>&nbsp;        // (gcode issue 504) Do not look into Maps if there is not MapKey annotation
<b class="fc"><i>444</i>&nbsp;        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();</b>
<b class="fc"><i>445</i>&nbsp;        if (actualTypeArguments != null &amp;&amp; actualTypeArguments.length == 2) {</b>
<b class="fc"><i>446</i>&nbsp;          Type returnTypeParameter = actualTypeArguments[1];</b>
<b class="fc"><i>447</i>&nbsp;          if (returnTypeParameter instanceof Class&lt;?&gt;) {</b>
<b class="fc"><i>448</i>&nbsp;            returnType = (Class&lt;?&gt;) returnTypeParameter;</b>
<b class="fc"><i>449</i>&nbsp;          } else if (returnTypeParameter instanceof ParameterizedType) {</b>
<i>450</i>&nbsp;            // (gcode issue 443) actual type can be a also a parameterized type
<b class="fc"><i>451</i>&nbsp;            returnType = (Class&lt;?&gt;) ((ParameterizedType) returnTypeParameter).getRawType();</b>
<i>452</i>&nbsp;          }
<i>453</i>&nbsp;        }
<b class="fc"><i>454</i>&nbsp;      } else if (Optional.class.equals(rawType)) {</b>
<b class="fc"><i>455</i>&nbsp;        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();</b>
<b class="fc"><i>456</i>&nbsp;        Type returnTypeParameter = actualTypeArguments[0];</b>
<b class="fc"><i>457</i>&nbsp;        if (returnTypeParameter instanceof Class&lt;?&gt;) {</b>
<b class="fc"><i>458</i>&nbsp;          returnType = (Class&lt;?&gt;) returnTypeParameter;</b>
<i>459</i>&nbsp;        }
<i>460</i>&nbsp;      }
<i>461</i>&nbsp;    }
<i>462</i>&nbsp;
<b class="fc"><i>463</i>&nbsp;    return returnType;</b>
<i>464</i>&nbsp;  }
<i>465</i>&nbsp;
<i>466</i>&nbsp;  private SqlSource getSqlSourceFromAnnotations(Method method, Class&lt;?&gt; parameterType, LanguageDriver languageDriver) {
<i>467</i>&nbsp;    try {
<b class="fc"><i>468</i>&nbsp;      Class&lt;? extends Annotation&gt; sqlAnnotationType = getSqlAnnotationType(method);</b>
<b class="fc"><i>469</i>&nbsp;      Class&lt;? extends Annotation&gt; sqlProviderAnnotationType = getSqlProviderAnnotationType(method);</b>
<b class="fc"><i>470</i>&nbsp;      if (sqlAnnotationType != null) {</b>
<b class="fc"><i>471</i>&nbsp;        if (sqlProviderAnnotationType != null) {</b>
<b class="nc"><i>472</i>&nbsp;          throw new BindingException(&quot;You cannot supply both a static SQL and SqlProvider to method named &quot; + method.getName());</b>
<i>473</i>&nbsp;        }
<b class="fc"><i>474</i>&nbsp;        Annotation sqlAnnotation = method.getAnnotation(sqlAnnotationType);</b>
<b class="fc"><i>475</i>&nbsp;        final String[] strings = (String[]) sqlAnnotation.getClass().getMethod(&quot;value&quot;).invoke(sqlAnnotation);</b>
<b class="fc"><i>476</i>&nbsp;        return buildSqlSourceFromStrings(strings, parameterType, languageDriver);</b>
<b class="fc"><i>477</i>&nbsp;      } else if (sqlProviderAnnotationType != null) {</b>
<b class="fc"><i>478</i>&nbsp;        Annotation sqlProviderAnnotation = method.getAnnotation(sqlProviderAnnotationType);</b>
<b class="fc"><i>479</i>&nbsp;        return new ProviderSqlSource(assistant.getConfiguration(), sqlProviderAnnotation, type, method);</b>
<i>480</i>&nbsp;      }
<b class="fc"><i>481</i>&nbsp;      return null;</b>
<b class="nc"><i>482</i>&nbsp;    } catch (Exception e) {</b>
<b class="nc"><i>483</i>&nbsp;      throw new BuilderException(&quot;Could not find value method on SQL annotation.  Cause: &quot; + e, e);</b>
<i>484</i>&nbsp;    }
<i>485</i>&nbsp;  }
<i>486</i>&nbsp;
<i>487</i>&nbsp;  private SqlSource buildSqlSourceFromStrings(String[] strings, Class&lt;?&gt; parameterTypeClass, LanguageDriver languageDriver) {
<b class="fc"><i>488</i>&nbsp;    final StringBuilder sql = new StringBuilder();</b>
<b class="fc"><i>489</i>&nbsp;    for (String fragment : strings) {</b>
<b class="fc"><i>490</i>&nbsp;      sql.append(fragment);</b>
<b class="fc"><i>491</i>&nbsp;      sql.append(&quot; &quot;);</b>
<i>492</i>&nbsp;    }
<b class="fc"><i>493</i>&nbsp;    return languageDriver.createSqlSource(configuration, sql.toString().trim(), parameterTypeClass);</b>
<i>494</i>&nbsp;  }
<i>495</i>&nbsp;
<i>496</i>&nbsp;  private SqlCommandType getSqlCommandType(Method method) {
<b class="fc"><i>497</i>&nbsp;    Class&lt;? extends Annotation&gt; type = getSqlAnnotationType(method);</b>
<i>498</i>&nbsp;
<b class="fc"><i>499</i>&nbsp;    if (type == null) {</b>
<b class="fc"><i>500</i>&nbsp;      type = getSqlProviderAnnotationType(method);</b>
<i>501</i>&nbsp;
<b class="fc"><i>502</i>&nbsp;      if (type == null) {</b>
<b class="nc"><i>503</i>&nbsp;        return SqlCommandType.UNKNOWN;</b>
<i>504</i>&nbsp;      }
<i>505</i>&nbsp;
<b class="fc"><i>506</i>&nbsp;      if (type == SelectProvider.class) {</b>
<b class="fc"><i>507</i>&nbsp;        type = Select.class;</b>
<b class="fc"><i>508</i>&nbsp;      } else if (type == InsertProvider.class) {</b>
<b class="fc"><i>509</i>&nbsp;        type = Insert.class;</b>
<b class="fc"><i>510</i>&nbsp;      } else if (type == UpdateProvider.class) {</b>
<b class="fc"><i>511</i>&nbsp;        type = Update.class;</b>
<b class="fc"><i>512</i>&nbsp;      } else if (type == DeleteProvider.class) {</b>
<b class="fc"><i>513</i>&nbsp;        type = Delete.class;</b>
<i>514</i>&nbsp;      }
<i>515</i>&nbsp;    }
<i>516</i>&nbsp;
<b class="fc"><i>517</i>&nbsp;    return SqlCommandType.valueOf(type.getSimpleName().toUpperCase(Locale.ENGLISH));</b>
<i>518</i>&nbsp;  }
<i>519</i>&nbsp;
<i>520</i>&nbsp;  private Class&lt;? extends Annotation&gt; getSqlAnnotationType(Method method) {
<b class="fc"><i>521</i>&nbsp;    return chooseAnnotationType(method, SQL_ANNOTATION_TYPES);</b>
<i>522</i>&nbsp;  }
<i>523</i>&nbsp;
<i>524</i>&nbsp;  private Class&lt;? extends Annotation&gt; getSqlProviderAnnotationType(Method method) {
<b class="fc"><i>525</i>&nbsp;    return chooseAnnotationType(method, SQL_PROVIDER_ANNOTATION_TYPES);</b>
<i>526</i>&nbsp;  }
<i>527</i>&nbsp;
<i>528</i>&nbsp;  private Class&lt;? extends Annotation&gt; chooseAnnotationType(Method method, Set&lt;Class&lt;? extends Annotation&gt;&gt; types) {
<b class="fc"><i>529</i>&nbsp;    for (Class&lt;? extends Annotation&gt; type : types) {</b>
<b class="fc"><i>530</i>&nbsp;      Annotation annotation = method.getAnnotation(type);</b>
<b class="fc"><i>531</i>&nbsp;      if (annotation != null) {</b>
<b class="fc"><i>532</i>&nbsp;        return type;</b>
<i>533</i>&nbsp;      }
<b class="fc"><i>534</i>&nbsp;    }</b>
<b class="fc"><i>535</i>&nbsp;    return null;</b>
<i>536</i>&nbsp;  }
<i>537</i>&nbsp;
<i>538</i>&nbsp;  private void applyResults(Result[] results, Class&lt;?&gt; resultType, List&lt;ResultMapping&gt; resultMappings) {
<b class="fc"><i>539</i>&nbsp;    for (Result result : results) {</b>
<b class="fc"><i>540</i>&nbsp;      List&lt;ResultFlag&gt; flags = new ArrayList&lt;&gt;();</b>
<b class="fc"><i>541</i>&nbsp;      if (result.id()) {</b>
<b class="fc"><i>542</i>&nbsp;        flags.add(ResultFlag.ID);</b>
<i>543</i>&nbsp;      }
<i>544</i>&nbsp;      @SuppressWarnings(&quot;unchecked&quot;)
<b class="fc"><i>545</i>&nbsp;      Class&lt;? extends TypeHandler&lt;?&gt;&gt; typeHandler = (Class&lt;? extends TypeHandler&lt;?&gt;&gt;)</b>
<b class="fc"><i>546</i>&nbsp;              ((result.typeHandler() == UnknownTypeHandler.class) ? null : result.typeHandler());</b>
<b class="fc"><i>547</i>&nbsp;      ResultMapping resultMapping = assistant.buildResultMapping(</b>
<i>548</i>&nbsp;          resultType,
<b class="fc"><i>549</i>&nbsp;          nullOrEmpty(result.property()),</b>
<b class="fc"><i>550</i>&nbsp;          nullOrEmpty(result.column()),</b>
<b class="fc"><i>551</i>&nbsp;          result.javaType() == void.class ? null : result.javaType(),</b>
<b class="fc"><i>552</i>&nbsp;          result.jdbcType() == JdbcType.UNDEFINED ? null : result.jdbcType(),</b>
<b class="fc"><i>553</i>&nbsp;          hasNestedSelect(result) ? nestedSelectId(result) : null,</b>
<i>554</i>&nbsp;          null,
<i>555</i>&nbsp;          null,
<i>556</i>&nbsp;          null,
<i>557</i>&nbsp;          typeHandler,
<i>558</i>&nbsp;          flags,
<i>559</i>&nbsp;          null,
<i>560</i>&nbsp;          null,
<b class="fc"><i>561</i>&nbsp;          isLazy(result));</b>
<b class="fc"><i>562</i>&nbsp;      resultMappings.add(resultMapping);</b>
<i>563</i>&nbsp;    }
<b class="fc"><i>564</i>&nbsp;  }</b>
<i>565</i>&nbsp;
<i>566</i>&nbsp;  private String nestedSelectId(Result result) {
<b class="fc"><i>567</i>&nbsp;    String nestedSelect = result.one().select();</b>
<b class="fc"><i>568</i>&nbsp;    if (nestedSelect.length() &lt; 1) {</b>
<b class="fc"><i>569</i>&nbsp;      nestedSelect = result.many().select();</b>
<i>570</i>&nbsp;    }
<b class="fc"><i>571</i>&nbsp;    if (!nestedSelect.contains(&quot;.&quot;)) {</b>
<b class="fc"><i>572</i>&nbsp;      nestedSelect = type.getName() + &quot;.&quot; + nestedSelect;</b>
<i>573</i>&nbsp;    }
<b class="fc"><i>574</i>&nbsp;    return nestedSelect;</b>
<i>575</i>&nbsp;  }
<i>576</i>&nbsp;
<i>577</i>&nbsp;  private boolean isLazy(Result result) {
<b class="fc"><i>578</i>&nbsp;    boolean isLazy = configuration.isLazyLoadingEnabled();</b>
<b class="fc"><i>579</i>&nbsp;    if (result.one().select().length() &gt; 0 &amp;&amp; FetchType.DEFAULT != result.one().fetchType()) {</b>
<b class="fc"><i>580</i>&nbsp;      isLazy = result.one().fetchType() == FetchType.LAZY;</b>
<b class="fc"><i>581</i>&nbsp;    } else if (result.many().select().length() &gt; 0 &amp;&amp; FetchType.DEFAULT != result.many().fetchType()) {</b>
<b class="fc"><i>582</i>&nbsp;      isLazy = result.many().fetchType() == FetchType.LAZY;</b>
<i>583</i>&nbsp;    }
<b class="fc"><i>584</i>&nbsp;    return isLazy;</b>
<i>585</i>&nbsp;  }
<i>586</i>&nbsp;
<i>587</i>&nbsp;  private boolean hasNestedSelect(Result result) {
<b class="fc"><i>588</i>&nbsp;    if (result.one().select().length() &gt; 0 &amp;&amp; result.many().select().length() &gt; 0) {</b>
<b class="fc"><i>589</i>&nbsp;      throw new BuilderException(&quot;Cannot use both @One and @Many annotations in the same @Result&quot;);</b>
<i>590</i>&nbsp;    }
<b class="fc"><i>591</i>&nbsp;    return result.one().select().length() &gt; 0 || result.many().select().length() &gt; 0;</b>
<i>592</i>&nbsp;  }
<i>593</i>&nbsp;
<i>594</i>&nbsp;  private void applyConstructorArgs(Arg[] args, Class&lt;?&gt; resultType, List&lt;ResultMapping&gt; resultMappings) {
<b class="fc"><i>595</i>&nbsp;    for (Arg arg : args) {</b>
<b class="fc"><i>596</i>&nbsp;      List&lt;ResultFlag&gt; flags = new ArrayList&lt;&gt;();</b>
<b class="fc"><i>597</i>&nbsp;      flags.add(ResultFlag.CONSTRUCTOR);</b>
<b class="fc"><i>598</i>&nbsp;      if (arg.id()) {</b>
<b class="fc"><i>599</i>&nbsp;        flags.add(ResultFlag.ID);</b>
<i>600</i>&nbsp;      }
<i>601</i>&nbsp;      @SuppressWarnings(&quot;unchecked&quot;)
<b class="fc"><i>602</i>&nbsp;      Class&lt;? extends TypeHandler&lt;?&gt;&gt; typeHandler = (Class&lt;? extends TypeHandler&lt;?&gt;&gt;)</b>
<b class="fc"><i>603</i>&nbsp;              (arg.typeHandler() == UnknownTypeHandler.class ? null : arg.typeHandler());</b>
<b class="fc"><i>604</i>&nbsp;      ResultMapping resultMapping = assistant.buildResultMapping(</b>
<i>605</i>&nbsp;          resultType,
<b class="fc"><i>606</i>&nbsp;          nullOrEmpty(arg.name()),</b>
<b class="fc"><i>607</i>&nbsp;          nullOrEmpty(arg.column()),</b>
<b class="fc"><i>608</i>&nbsp;          arg.javaType() == void.class ? null : arg.javaType(),</b>
<b class="fc"><i>609</i>&nbsp;          arg.jdbcType() == JdbcType.UNDEFINED ? null : arg.jdbcType(),</b>
<b class="fc"><i>610</i>&nbsp;          nullOrEmpty(arg.select()),</b>
<b class="fc"><i>611</i>&nbsp;          nullOrEmpty(arg.resultMap()),</b>
<i>612</i>&nbsp;          null,
<b class="fc"><i>613</i>&nbsp;          nullOrEmpty(arg.columnPrefix()),</b>
<i>614</i>&nbsp;          typeHandler,
<i>615</i>&nbsp;          flags,
<i>616</i>&nbsp;          null,
<i>617</i>&nbsp;          null,
<i>618</i>&nbsp;          false);
<b class="fc"><i>619</i>&nbsp;      resultMappings.add(resultMapping);</b>
<i>620</i>&nbsp;    }
<b class="fc"><i>621</i>&nbsp;  }</b>
<i>622</i>&nbsp;
<i>623</i>&nbsp;  private String nullOrEmpty(String value) {
<b class="fc"><i>624</i>&nbsp;    return value == null || value.trim().length() == 0 ? null : value;</b>
<i>625</i>&nbsp;  }
<i>626</i>&nbsp;
<i>627</i>&nbsp;  private Result[] resultsIf(Results results) {
<b class="fc"><i>628</i>&nbsp;    return results == null ? new Result[0] : results.value();</b>
<i>629</i>&nbsp;  }
<i>630</i>&nbsp;
<i>631</i>&nbsp;  private Arg[] argsIf(ConstructorArgs args) {
<b class="fc"><i>632</i>&nbsp;    return args == null ? new Arg[0] : args.value();</b>
<i>633</i>&nbsp;  }
<i>634</i>&nbsp;
<i>635</i>&nbsp;  private KeyGenerator handleSelectKeyAnnotation(SelectKey selectKeyAnnotation, String baseStatementId, Class&lt;?&gt; parameterTypeClass, LanguageDriver languageDriver) {
<b class="fc"><i>636</i>&nbsp;    String id = baseStatementId + SelectKeyGenerator.SELECT_KEY_SUFFIX;</b>
<b class="fc"><i>637</i>&nbsp;    Class&lt;?&gt; resultTypeClass = selectKeyAnnotation.resultType();</b>
<b class="fc"><i>638</i>&nbsp;    StatementType statementType = selectKeyAnnotation.statementType();</b>
<b class="fc"><i>639</i>&nbsp;    String keyProperty = selectKeyAnnotation.keyProperty();</b>
<b class="fc"><i>640</i>&nbsp;    String keyColumn = selectKeyAnnotation.keyColumn();</b>
<b class="fc"><i>641</i>&nbsp;    boolean executeBefore = selectKeyAnnotation.before();</b>
<i>642</i>&nbsp;
<i>643</i>&nbsp;    // defaults
<b class="fc"><i>644</i>&nbsp;    boolean useCache = false;</b>
<b class="fc"><i>645</i>&nbsp;    KeyGenerator keyGenerator = NoKeyGenerator.INSTANCE;</b>
<b class="fc"><i>646</i>&nbsp;    Integer fetchSize = null;</b>
<b class="fc"><i>647</i>&nbsp;    Integer timeout = null;</b>
<b class="fc"><i>648</i>&nbsp;    boolean flushCache = false;</b>
<b class="fc"><i>649</i>&nbsp;    String parameterMap = null;</b>
<b class="fc"><i>650</i>&nbsp;    String resultMap = null;</b>
<b class="fc"><i>651</i>&nbsp;    ResultSetType resultSetTypeEnum = null;</b>
<i>652</i>&nbsp;
<b class="fc"><i>653</i>&nbsp;    SqlSource sqlSource = buildSqlSourceFromStrings(selectKeyAnnotation.statement(), parameterTypeClass, languageDriver);</b>
<b class="fc"><i>654</i>&nbsp;    SqlCommandType sqlCommandType = SqlCommandType.SELECT;</b>
<i>655</i>&nbsp;
<b class="fc"><i>656</i>&nbsp;    assistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType, fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass, resultSetTypeEnum,</b>
<i>657</i>&nbsp;        flushCache, useCache, false,
<i>658</i>&nbsp;        keyGenerator, keyProperty, keyColumn, null, languageDriver, null);
<i>659</i>&nbsp;
<b class="fc"><i>660</i>&nbsp;    id = assistant.applyCurrentNamespace(id, false);</b>
<i>661</i>&nbsp;
<b class="fc"><i>662</i>&nbsp;    MappedStatement keyStatement = configuration.getMappedStatement(id, false);</b>
<b class="fc"><i>663</i>&nbsp;    SelectKeyGenerator answer = new SelectKeyGenerator(keyStatement, executeBefore);</b>
<b class="fc"><i>664</i>&nbsp;    configuration.addKeyGenerator(id, answer);</b>
<b class="fc"><i>665</i>&nbsp;    return answer;</b>
<i>666</i>&nbsp;  }
<i>667</i>&nbsp;
<i>668</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2019-03-04 09:14</div>
</div>
</body>
</html>
